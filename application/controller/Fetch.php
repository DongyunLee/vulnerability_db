<?php
/**
 * Fetch.php - VulnerabilityDatabase
 * By lidongyun@shuwang-tech.com
 * On 2019/5/16 13:03
 * Doing good deeds without asking for reward
 */

namespace app\controller;

use app\model\Bugtraq;
use app\model\Cves;
use app\model\Files;
use app\model\Log;
use app\model\Products;
use app\model\VulBidRelationship;
use app\model\VulCveRelationship;
use app\model\Vulnerabilitys;
use app\model\VulProRelationship;
use think\Controller;
use think\Exception;
use think\facade\Url;
use think\Request;

/**
 * 自动抓取控制器
 * Class Fetch
 *
 * @property mixed id
 * @package app\index\controller
 */
class Fetch extends Controller
{
    /**
     * 显示上传xml的页面
     *
     * @return mixed
     */
    public function index()
    {
        $this->assign('action', Url::build('syn'));

        return $this->fetch('/fetch');
    }

    /**
     * 进行同步的逻辑
     *
     * @param \think\Request $request
     *
     * @throws \Exception
     */
    public function syn(Request $request)
    {
        // 接收xml
        $xml = $request->file('xml');

        // 解析xml
        $data = file_get_contents($xml->getPathname());
        // 准备记录数据
        $file_name = $xml->getInfo('name');

        exit('<script>alert("' . (self::synDb($data, $file_name)
                ? '添加成功!'
                : '添加失败!') . '");history.go(-1)</script>');
    }

    /**
     * 解析XML
     *
     * @param string $xml
     *
     * @return array
     * @throws \think\Exception
     */
    private static function parseXML(string $xml)
    {
        $simple_xml_object = simplexml_load_string($xml);

        if (!$simple_xml_object) throw new Exception('xml格式有误，请检查后再试');
        $xml_data_array = [];

        foreach ($simple_xml_object->children() as $name => $value) {
            $value = json_decode(json_encode($value), true);
            $xml_data_array[] = [
                // cnvd编号
                'cnvd_id' => $value['number'],
                // 漏洞名称
                'title' => $value['title'],
                // 漏洞危害等级
                'serverity' => $value['serverity'],
                // 漏洞类型（是否为事件型漏洞）
                'is_event' => $value['isEvent'],
                // 漏洞报送时间
                'submit_time' => strtotime($value['submitTime']),
                // 漏洞公开时间
                'open_time' => strtotime($value['openTime']),
                // 漏洞发现者
                'discoverer_name' => $value['discovererName'] ?? '',
                // 解决办法
                'formal_way' => $value['formalWay'],
                // 漏洞描述
                'description' => $value['description'],
                // 补丁名称
                'patch_name' => $value['patchName'] ?? '',
                // 补丁描述
                'patch_description' => $value['patchDescription'] ?? '',
                'bids' => isset($value['bids']['bid']) && !empty($value['bids']['bid'])
                    ? (isset($value['bids']['bid']['bidNumber'])
                        ? [$value['bids']['bid']]
                        : $value['bids']['bid'])
                    : [],
                'cves' => isset($value['cves']['cve']) && !empty($value['cves']['cve'])
                    ? (isset($value['cves']['cve']['cveNumber'])
                        ? [$value['cves']['cve']]
                        : $value['cves']['cve'])
                    : [],
                'products' => isset($value['products']['product']) && !empty($value['products']['product'])
                    ? (is_string($value['products']['product'])
                        ? [$value['products']['product']]
                        : [])
                    : []
            ];
        }
        return $xml_data_array;
    }

    /**
     * 数据库存储方法
     *
     * @param $xml
     * @param $file_name
     *
     * @return bool
     * @throws \Exception
     */
    public static function synDb($xml, $file_name): bool
    {
        /** @var int $start_time 记录开始时间 */
        $start_time = time();
        $log_data = [
            'file_name' => $file_name
        ];

        try {
            /** @var \Generator $data 得到xml的生成器 */
            $data = self::parseXML($xml);
            // 如果已存在则不插入
            $file = Files::where(['title' => $log_data['file_name']])
                ->findOrEmpty();
            if ($file->isEmpty()) {
                $add_file_result = Files::create([
                    'title' => $log_data['file_name']
                ]);
                if (!$add_file_result) throw new Exception('文件表插入失败，文件名为' . $log_data['file_name'], 90001);
                $files_id = $add_file_result['id'];
            } else {
                $files_id = $file['id'];
            }

            foreach ($data as $datum) {
                $datum['files_id'] = $files_id;

                // 解析bid
                if (isset($datum['bids'])) {
                    $bids = $datum['bids'];
                    unset($datum['bids']);
                    if (is_array($bids) && count($bids) > 0) {

                        $bid_id_list = [];
                        foreach ($bids as $bid) {
                            if (!isset($bid['bidNumber']) || empty($bid['bidNumber'])) continue;
                            $bid_datum = [
                                'bid_number' => $bid['bidNumber']
                            ];
                            if (isset($bid['bidUrl']) && !empty($bid['bidUrl'])) $bid_datum['bid_url'] = $bid['bidUrl'];
                            // 如果已存在则不插入
                            $bid_data = Bugtraq::where(['bid_number' => $bid_datum['bid_number']])
                                ->findOrEmpty();
                            if (!$bid_data->isEmpty()) {
                                $bid_id_list[] = $bid_data['id'];
                                continue;
                            }

                            // 插入bid
                            $result = Bugtraq::create($bid_datum);
                            if ($result->isEmpty()) throw new Exception('插入bid失败，信息为' . json_encode($bid_datum), 90002);
                            $bid_id_list[] = $result['id'];
                        }
                    }
                }

                // 解析cve
                if (isset($datum['cves'])) {
                    $cves = $datum['cves'];
                    unset($datum['cves']);
                    if (is_array($cves) && count($cves) > 0) {

                        $cve_id_list = [];
                        foreach ($cves as $cve) {
                            if (!isset($cve['cveNumber']) || empty($cve['cveNumber'])) continue;
                            $cve_datum = [
                                'cve_number' => $cve['cveNumber']
                            ];
                            if (isset($cve['cveUrl']) && !empty($cve['cveUrl'])) $cve_datum['cve_url'] = $cve['cveUrl'];
                            // 如果已存在则不插入
                            $cve_data = Cves::where(['cve_number' => $cve_datum['cve_number']])
                                ->findOrEmpty();
                            if (!($cve_data->isEmpty())) {
                                $cve_id_list[] = $cve_data['id'];
                                continue;
                            }

                            // 插入cve
                            $result = Cves::create($cve_datum);
                            if ($result->isEmpty()) throw new Exception('插入cve失败，信息为' . json_encode($cve_datum), 90003);
                            $cve_id_list[] = $result['id'];
                        }
                    }
                }

                // 解析受影响的产品
                if (isset($datum['products'])) {

                    $products = $datum['products'];
                    unset($datum['products']);
                    if (is_array($products) && count($products) > 0) {
                        $products_id_list = [];
                        foreach ($products as $product) {
                            if (!isset($product) || empty($product)) continue;

                            // 如果已存在则不插入
                            $product_data = Products::where(['name' => $product])
                                ->findOrEmpty();
                            if (!($product_data->isEmpty())) {
                                $products_id_list[] = $product_data['id'];
                                continue;
                            }

                            // 插入product
                            $result = Products::create(['name' => $product]);
                            if ($result->isEmpty()) {
                                throw new Exception('插入product失败，信息为' . json_encode(['name' => $product]), 90002);
                            }
                            $products_id_list[] = $result['id'];
                        }
                    }
                }
                // 如果已存在则不插入
                $vulnerability_data = Vulnerabilitys::where($datum)
                    ->find();
                if ($vulnerability_data !== null) {
                    $v_id = $vulnerability_data['id'];
                } else {

                    // 记录漏洞
                    $v_insert_result = Vulnerabilitys::create($datum);
                    if ($v_insert_result->isEmpty()) throw new Exception('漏洞插入失败，数据为' . json_encode($datum), 90004);

                    $v_id = $v_insert_result['id'];
                }

                // 绑定bid和漏洞的关联关系
                if (!empty($bid_id_list) && count($bid_id_list) > 0) {
                    $data_v_bid = [];
                    foreach ($bid_id_list as $item) {
                        $data_v_bid[] = [
                            'v_id' => $v_id,
                            'b_id' => $item
                        ];
                    }
                    $add_v_b_relationship_result = (new VulBidRelationship)->saveAll($data_v_bid);
                    if ($add_v_b_relationship_result->isEmpty()) throw new Exception('table v_bid_relationship insert fault, error data is: ' . json_encode($data_v_bid),
                        90012);
                }

                // 绑定cve和漏洞的关联关系
                if (!empty($cve_id_list) && count($cve_id_list) > 0) {
                    $data_v_cve = [];
                    foreach ($cve_id_list as $item) {
                        $data_v_cve[] = [
                            'v_id' => $v_id,
                            'cve_id' => $item
                        ];
                    }
                    $add_v_cve_relationship_result = (new VulCveRelationship())->saveAll($data_v_cve);
                    if ($add_v_cve_relationship_result->isEmpty()) throw new Exception('table v_cve_relationship insert fault, error data is: ' . json_encode($data_v_cve),
                        90013);
                }

                // 绑定受影响的产品和漏洞的关联关系
                if (!empty($products_id_list) && count($products_id_list) > 0) {
                    $data_v_product = [];
                    foreach ($products_id_list as $item) {
                        $data_v_product[] = [
                            'v_id' => $v_id,
                            'pro_id' => $item
                        ];
                    }
                    $add_v_product_relationship_result = (new VulProRelationship())->saveAll($data_v_product);
                    if ($add_v_product_relationship_result->isEmpty()) throw new Exception('table v_product_relationship insert fault, error data is: ' . json_encode($data_v_product),
                        90014);
                }
            }

            $log_data['status'] = 1;
            if (Log::create($log_data)->isEmpty()) throw new Exception('日志记录失败');

            /** @var int $end_time 记录结束时间 */
            $end_time = time();

            /** @var int $pay_time 计算花费的秒数 */
            $pay_time = $end_time - $start_time;
            \think\facade\Log::info("导入成功！共计花费{$pay_time}秒");
            return true;
        } catch (Exception $exception) {
            $log_data['status'] = 0;
            Log::create($log_data);
            $code = $exception->getCode() == 0
                ? 99999
                : $exception->getCode();
            $log = "[{$code}]导入失败。{$exception->getMessage()}";
            \think\facade\Log::error($log);

            return false;
        }
    }

}